"""MalwareBazaar (abuse.ch) feed connector — malware file hashes.

Free, no API key required. Uses the CSV export endpoint.
Docs: https://bazaar.abuse.ch/api/
"""

from __future__ import annotations

import csv
import io
import uuid
from datetime import datetime, timezone

from app.core.logging import get_logger
from app.services.feeds.base import BaseFeedConnector

logger = get_logger(__name__)

MALWAREBAZAAR_CSV_URL = "https://bazaar.abuse.ch/export/csv/recent/"


class MalwareBazaarConnector(BaseFeedConnector):
    FEED_NAME = "malwarebazaar"
    SOURCE_RELIABILITY = 80

    async def fetch(self, last_cursor: str | None = None) -> list[dict]:
        """Fetch recent malware samples from MalwareBazaar CSV export."""
        response = await self.client.get(MALWAREBAZAAR_CSV_URL)
        response.raise_for_status()

        text = response.text
        # Skip comment lines (start with #)
        lines = [l for l in text.strip().split("\n") if not l.startswith("#")]
        if not lines:
            return []

        reader = csv.DictReader(
            io.StringIO("\n".join(lines)),
            fieldnames=[
                "first_seen_utc", "sha256_hash", "md5_hash", "sha1_hash",
                "reporter", "file_name", "file_type_guess", "mime_type",
                "signature", "clamav", "vtpercent", "imphash", "ssdeep", "tlsh",
            ],
        )

        items = list(reader)
        logger.info("malwarebazaar_fetch", total=len(items))

        # Incremental: filter by first_seen > last_cursor
        if last_cursor:
            try:
                cursor_dt = datetime.fromisoformat(last_cursor)
                items = [
                    i for i in items
                    if self._parse_date(i.get("first_seen_utc"))
                    and self._parse_date(i.get("first_seen_utc")) > cursor_dt
                ]
            except (ValueError, TypeError):
                pass

        return items[:500]

    def _parse_date(self, date_str: str | None) -> datetime | None:
        if not date_str:
            return None
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S"):
            try:
                return datetime.strptime(date_str, fmt).replace(tzinfo=timezone.utc)
            except (ValueError, TypeError):
                continue
        return None

    def _severity_from_tags(self, tags: list[str]) -> str:
        """Heuristic severity from tags / known ransomware families."""
        tag_lower = [t.lower() for t in tags]
        critical_kw = {"ransomware", "apt", "cobalt", "cobaltstrike", "emotet", "trickbot", "qakbot"}
        high_kw = {"trojan", "rat", "stealer", "loader", "backdoor", "miner"}
        if critical_kw & set(tag_lower):
            return "critical"
        if high_kw & set(tag_lower):
            return "high"
        return "medium"

    def normalize(self, raw_items: list[dict]) -> list[dict]:
        items = []
        for raw in raw_items:
            sha256 = (raw.get("sha256_hash") or "").strip().strip('"')
            if not sha256 or len(sha256) < 32:
                continue

            signature = (raw.get("signature") or "n/a").strip().strip('"')
            if signature == "n/a":
                signature = "unknown"
            file_type = (raw.get("file_type_guess") or "unknown").strip().strip('"')
            file_name = (raw.get("file_name") or "unknown").strip().strip('"')

            # CSV export doesn't have separate tags — derive from signature
            tags = ["malwarebazaar"]
            if signature and signature != "unknown":
                tags.append(signature.lower().replace(" ", "_"))

            published_at = self._parse_date(
                (raw.get("first_seen_utc") or "").strip().strip('"')
            )
            severity = self._severity_from_tags(tags)

            reporter = (raw.get("reporter") or "anonymous").strip().strip('"')
            md5 = (raw.get("md5_hash") or "N/A").strip().strip('"')
            sha1 = (raw.get("sha1_hash") or "N/A").strip().strip('"')

            items.append({
                "id": uuid.uuid4(),
                "title": f"[MalwareBazaar] {signature}: {sha256[:16]}…",
                "summary": (
                    f"File: {file_name} | Type: {file_type} | "
                    f"Sig: {signature}"
                ),
                "description": (
                    f"Malware sample from MalwareBazaar. SHA256: {sha256}. "
                    f"MD5: {md5}. SHA1: {sha1}. "
                    f"File: {file_name} ({file_type}). "
                    f"Signature: {signature}. Reporter: {reporter}."
                ),
                "published_at": published_at,
                "ingested_at": self.now_utc(),
                "updated_at": self.now_utc(),
                "severity": severity,
                "risk_score": 0,
                "confidence": 80,
                "source_name": "MalwareBazaar",
                "source_url": f"https://bazaar.abuse.ch/sample/{sha256}/",
                "source_reliability": self.SOURCE_RELIABILITY,
                "source_ref": sha256,
                "feed_type": "ioc",
                "asset_type": "hash_sha256",
                "tlp": "TLP:CLEAR",
                "tags": tags,
                "geo": [],
                "industries": [],
                "cve_ids": [],
                "affected_products": [],
                "related_ioc_count": 1,
                "is_kev": False,
                "exploit_available": False,
                "exploitability_score": None,
                "source_hash": self.generate_hash("malwarebazaar", sha256),
            })

        return items
